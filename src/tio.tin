# tio.tcl
################################################################################
# Data import and export, and datatype conversions

# Copyright (C) 2023 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" in the top level directory for information on usage, 
# redistribution, and for a DISCLAIMER OF ALL WARRANTIES.
################################################################################

# Required packages
package require vutil @VUTIL_VERSION@
package require ndlist @NDLIST_VERSION@
package require taboo @TABOO_VERSION@

# Define namespace
namespace eval ::tio {
    # Basic file input/output
    namespace export fread fputs; # basic read/write (raw strings)
    namespace export mread mputs; # matrix read/write
    namespace export tread tputs; # table read/write
    # Data conversions
    namespace export mat2tbl tbl2mat; # matrix <-> table
    namespace export mat2txt txt2mat; # matrix <-> text
    namespace export mat2csv csv2mat; # matrix <-> CSV
    namespace export tbl2txt txt2tbl; # table <-> text
    namespace export tbl2csv csv2tbl; # table <-> CSV
    namespace export txt2csv csv2txt; # text <-> CSV
}

# File input/output
################################################################################

# fread --
#
# Loads data from file, ignoring last newline
#
# Syntax:
# fread <$options ...> <-newline> $file
#
# Arguments:
# options:          Options to pass to "fconfigure"
# -newline:         Read the last newline (default ignores last newline)
# file:             File to read from

proc ::tio::fread {args} {
    # Check arity
    if {[llength $args] == 0} {
        return -code error "wrong # args: should be \"fread\
                ?option value ...? ?-newline? file\""
    }
    # Parse optional arguments
    set options [lrange $args 0 end-1]
    set nonewline true
    if {[llength $options]%2 == 1} {
        if {[lindex $options end] ne "-newline"} {
            return -code error "wrong # args: should be \"fread\
                    ?option value ...? ?-newline? file\""
        }
        set nonewline false
        set options [lrange $options 0 end-1]; # trim -newline
    }
    # Interpret remaining args
    set file [lindex $args end]
    set options [lrange $args 0 end-1]
    # Try to open file for reading, and configure as specified
    set fid [open $file r]
    fconfigure $fid {*}$options
    # Read string from file
    if {$nonewline} {
        set string [read -nonewline $fid]
    } else {
        set string [read $fid]
    }
    close $fid
    return $string
}

# fputs --
# 
# Overwrite file with data, with additional options
#
# Syntax:
# fputs <$options ...> <-nonewline> $file $string
#
# Arguments:
# options:          Options to pass to "fconfigure"
# -nonewline:       Option to not write a final newline
# file:             File to write to
# string:           String to write to file

proc ::tio::fputs {args} {
    # Check arity
    if {[llength $args] < 2} {
        return -code error "wrong # args: should be \"fputs\
                ?option value ...? ?-nonewline? file string\""
    }
    # Parse optional arguments
    set options [lrange $args 0 end-2]
    set nonewline false
    if {[llength $options]%2 == 1} {
        if {[lindex $options end] ne "-nonewline"} {
            return -code error "wrong # args: should be \"fputs\
                    ?option value ...? ?-nonewline? file string\""
        }
        set nonewline true
        set options [lrange $options 0 end-1]; # trim -nonewline
    }
    # Interpret remaining args
    set file [lindex $args end-1]
    set string [lindex $args end]
    # Try to open file for writing, and configure as specified
    file mkdir [file dirname $file]
    set fid [open $file w]
    fconfigure $fid {*}$args
    # Write data to file
    if {$nonewline} {
        puts -nonewline $fid $string
    } else {
        puts $fid $string
    }
    close $fid
    return
}

# mread --
#
# Read matrix from file.
#
# Syntax:
# mread $refName <$options ...> <-newline> $file
#
# Arguments:
# refName:          Variable for garbage collection
# options:          Options to pass to "fconfigure"
# -newline:         Read the last newline (default ignores last newline)
# file:             File to read from

proc ::tio::mread {refName args} {
    # Switch for file extension
    if {[file extension [lindex $args end]] eq ".csv"} {
        set matrix [csv2mat [fread {*}$args]]
    } else {
        set matrix [txt2mat [fread {*}$args]]
    }
    upvar 1 $refName var 
    ::ndlist::matrix var $matrix
}

# mputs --
#
# Write matrix to file.
#
# Syntax:
# mputs $matObj <$options ...> <-nonewline> $file
#
# Arguments:
# matObj:           Matrix object
# options:          Options to pass to "fconfigure"
# -newline:         Read the last newline (default ignores last newline)
# file:             File to read from

proc ::tio::mputs {matObj args} {
    # Assert matrix type
    ::vutil::type assert ndlist $matObj
    if {[$matObj ndims] != 2} {
        return -code error "$matObj is [$matObj ndims]D, want 2D"
    }
    # Switch for file extension
    if {[file extension [lindex $args end]] eq ".csv"} { 
        fputs {*}$args [mat2csv [$matObj]]
    } else {
        fputs {*}$args [mat2txt [$matObj]]
    }
    return
}

# tread --
#
# Read table object from file.
#
# Syntax:
# tread $refName <$options ...> <-newline> $file
#
# Arguments:
# refName:          Variable for garbage collection
# options:          Options to pass to "fconfigure"
# -newline:         Read the last newline (default ignores last newline)
# file:             File to read from

proc ::tio::tread {refName args} {
    # Switch for file extension
    if {[file extension [lindex $args end]] eq ".csv"} {
        set table [csv2tbl [fread {*}$args]]
    } else {
        set table [txt2tbl [fread {*}$args]]
    }
    upvar 1 $refName var 
    ::taboo::table var $table
}

# tputs --
#
# Write table object to file.
#
# Syntax:
# tputs $tblObj <$options ...> <-nonewline> $file
#
# Arguments:
# tblObj:           Table object
# options:          Options to pass to "fconfigure"
# -nonewline:       Option to not write a final newline
# file:             File to write to

proc ::tio::tputs {tblObj args} {
    # Assert table type
    ::vutil::type assert table $tblObj
    # Switch for file extension
    if {[file extension [lindex $args end]] eq ".csv"} { 
        fputs {*}$args [tbl2csv [$tblObj]]
    } else {
        fputs {*}$args [tbl2txt [$tblObj]]
    }
    return
}

# Raw data conversions
################################################################################
# mat: Base type. List of rows, using Tcl lists. See ndlist package.
# tbl: Zipped list of header row and columns. See taboo package.
# txt: Space-delineated with newlines to separate rows (actually Tcl lists)
# csv: Comma-separated values, with newlines to separate rows.
################################################################################

# mat2tbl --
#
# Convert from matrix to table
#
# Syntax:
# mat2tbl $matrix
#
# Arguments:
# matrix:       Matrix value to convert

proc ::tio::mat2tbl {matrix} {
    # Extract header from matrix
    set rows [lassign $matrix header]
    # Construct table
    set table ""
    foreach field $header column [::ndlist::Transpose $rows] {
        lappend table $field $column
    }
    # Return table value
    return $table
}

# tbl2mat --
#
# Convert from table value to matrix value.
#
# Syntax:
# tbl2mat $table
#
# Arguments:
# table:        Table value to convert

proc ::tio::tbl2mat {table} {
    # Extract header and columns from table
    set header ""
    set columns ""
    foreach {field column} $table {
        lappend header $field
        lappend columns $column
    }
    # Construct matrix
    set rows [::ndlist::Transpose $columns]
    set matrix [list $header {*}$rows]
    # Return matrix value
    return $matrix
}

# txt2mat --
#
# Convert from space-delimited text to matrix
# Newlines can be escaped inside curly braces
# Ignores blank lines
#
# Syntax:
# txt2mat $text
#
# Arguments:
# text:     Text to convert.

proc ::tio::txt2mat {text} {
    set matrix ""
    set row ""
    foreach line [split $text \n] {
        # Add to row, and handle escaped newlines
        append row $line
        if {[string is list $row]} {
            lappend matrix $row
            set row ""
        } else {
            append row \n
        }
    }
    return $matrix
}

# mat2txt --
#
# Convert from matrix to space-delimited text
#
# Syntax:
# mat2txt $matrix
#
# Arguments:
# matrix:       Matrix value

proc ::tio::mat2txt {matrix} {
    join $matrix \n
}

# csv2mat --
#
# Convert from comma-separated values to matrix
# Ignores blank lines
#
# Syntax:
# csv2mat $csv
#
# Arguments:
# csv:          CSV string to convert

proc ::tio::csv2mat {csv} {
    # Initialize variables
    set matrix ""; # Output matrix
    set csvRow ""; # CSV-formatted row of data
    set val ""; # Value in matrix row
    
    # Split csv by newline and loop through lines
    foreach line [split $csv \n] {
        append csvRow $line
        # Check for escaped newline condition
        if {[regexp -all "\"" $csvRow] % 2} {
            # Odd number of quotes
            append csvRow \n
            continue
        }
        # Split csv row by comma and loop through items, creating matrix row
        set row ""; # Matrix row of data
        set blanks 0; # Number of blanks (ignore blank rows)
        foreach item [split $csvRow ,] {
            append val $item
            # Check for escaped comma condition
            if {[regexp -all "\"" $val] % 2} {
                # Odd number of quotes
                append val ,
                continue
            }
            # Check if escaped (commas, newlines, or quotes)
            if {[regexp "\"" $val]} {
                # Remove outer escaping quotes
                set val [string range $val 1 end-1]
                # Check for escaped quotes
                if {[regexp "\"" $val]} {
                    # Replace with normal quotes
                    set val [regsub -all "\"\"" $val "\""]
                }
            }
            if {$val eq ""} {
                incr blanks
            }
            # Add to row
            lappend row $val
            # Clear val
            set val ""
        }
        # Add to matrix
        lappend matrix $row
        # Clear csv row
        set csvRow ""
    }
    return $matrix
}

# mat2csv --
#
# Convert from matrix to comma-separated values
#
# Arguments:
# matrix:       Matrix to convert

proc ::tio::mat2csv {matrix} {
    set csvLines ""
    # Loop through matrix rows
    foreach row $matrix {
        set csvRow ""
        foreach val $row {
            # Perform escaping if required
            if {[string match "*\[\",\r\n\]*" $val]} {
                set val "\"[string map [list \" \"\"] $val]\""
            }
            lappend csvRow $val
        }
        lappend csvLines [join $csvRow ,]
    }
    return [join $csvLines \n]
}

# Derived conversions
################################################################################

# From Table (tbl)
proc ::tio::tbl2csv {table} {mat2csv [tbl2mat $table]}
proc ::tio::tbl2txt {table} {mat2txt [tbl2mat $table]}

# From Text (txt)
proc ::tio::txt2tbl {text} {mat2tbl [txt2mat $text]}
proc ::tio::txt2csv {text} {mat2csv [txt2mat $text]}

# From CSV (csv)
proc ::tio::csv2tbl {csv} {mat2tbl [csv2mat $csv]}
proc ::tio::csv2txt {csv} {mat2txt [csv2mat $csv]}

# Finally, provide the package
package provide tio @VERSION@
